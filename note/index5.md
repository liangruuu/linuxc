# 数据中继原理解析

在IO层面按照一开始整理的思路来讲包括标准IO、系统调用IO、文件系统、并发，有了这些内容之后就可以回过头去再看IO，IO是所有实现的基础

高级IO：非阻塞IO——阻塞IO

阻塞IO意味必须把某个任务完成，读不完内容就不结束，非阻塞IO意味着做任务都是尝试着去做，如果不能做的话就返回

open函数的man手册中会有一些ERRORS，ERRORS就是当前可能会发生错误的情况，也就是在设置errno之后代表的是哪些出错情况

>ERRORS
>
>> EINTR  
>> While  blocked  waiting to complete an open of a slow device (e.g., a FIFO; see fifo(7)), the call was interrupted by a signal handler; see signal(7).
>>
>> EAGAIN 
>> The file descriptor fd refers to a file other than a socket and has been marked nonblocking (O_NONBLOCK), and  the read would block.  See open(2) for further details on the O_NONBLOCK flag.
>
>1. EINTR指的是当前如果在操作一个比较慢的设备的话，那么这个操作会被信号打断
>2. EAGAIN指的是当前操作如果是非阻塞的方式，那么就有可能发生EAGAIN假错

1. 除了阻塞情况下会有一个假错，假错不是因为操作失败而是因为当前的操动作非常慢，是一个阻塞的系统调用，总做不完要完成的那个任务，这时有信号过来就会打断一个正在阻塞的系统调用
2. 比如说读打印机，如果用阻塞的方式去读的话，那么就意味着读打印机必须读到内容为止；用非阻塞的方式的话读打印机，一读，有内容拿回来，没内容也回来，但是这个回来会被当做一个出错的返回，如果查看errno的话，这个errno值会是EAGAIN。也就是说这不是真正意义上的出错，是因为做这件事情尝试去做了，但是没有成功，只是因为现在没有数据而不是当前read函数的问题

高级IO这一部分主要是来研究非阻塞IO，在讲非阻塞IO的时候会介绍一种编程思路：有限状态机

1. 非阻塞IO
2. IO多路转接
3. 其他读写函数
4. 储存映射IO
5. 文件锁

假设有两个正常打开的设备，现在要用这两个设备进行数据交换：把左边设备L的数据拿到右边的设备R去，数据可能在右边的设备进行加工，再把右边的数据拿回到左边的设备中区去，有以下几种方式

1. 从任务的角度讨论，读L写R，然后读R写L，这样转一圈相当于四个工作，假设用阻塞的形式实现的话就会出现一些问题，比如读左边设备的数据，但是一直没有数据出现，那么就一定会阻塞在读L这样的动作上，这时如果有信号来打断的话，一判断是加假错，然后继续读，但是右边的设备不断地会有数据到来，其实如果先读R写L，再读L写R的话这个循环就能正常执行，结果一直在读L，L一直没数据，那就没办法读R写L。对于刚才的这一套流程是只针对一个线程或者进程而言的，总而言之没有协同操作，只是一个人在完成
2. 分为两个线程或进程，一个用来读L并且写R，一个用来读R并且写L，那么哪一端有数据那么哪一端就可以先执行，用第二种方式还可以勉强去考虑使用
3. 如果换成非阻塞方式只用一个线程或进程也能实现这个读写操作：企图读L，没数据，那么就换R去读，如果R没数据再去读L，再没数据就又去读R，左右横跳以此类推













